const MqttNetBus = require('./MQTTBus');
const matchTopic = require('../utils/TopicExtension').matchTopic;

class Communicator{
    networkBus;

    constructor(_peerId) {
        this.peerId = _peerId;
        this.subscriptions = {};
        this.networkBus = new MqttNetBus();
        this.networkBus.setMessageCallbackFunction(this.networkBusOnMessageReceived);
    };

    isConnected = () => {
        return this.networkBus.isConnected;
    }

    configure = (_host, _port, _username, _password, _peerName) => {
        this.networkBus.configure(_host, _port, _username, _password, this.peerId, _peerName);
    }

    connect = async (_lastWillMessage) => {
        return await this.networkBus.connect(_lastWillMessage);
    };

    disconnect = async () => {
        return await this.networkBus.disconnect();
    };

    /**
     * remove all stored subscriptions
     */
    clearSubscriptions = () => {
        this.subscriptions = {};
    };

    /**
     * reconnect and resubscribe
     */
    reconnect = async (_lastWillMessage) => {
        if(this.networkBus.isConnected){
            await this.networkBus.disconnect();
            await this.networkBus.connect(_lastWillMessage);
            // go through all the subscribtions that are no clones and resubscribe
            for (const key of Object.keys(this.subscriptions)) {
                const msg = this.subscriptions[key];
                if(!msg.autoGenerated){
                    await this.networkBus.subscribe(msg.QoS, msg.topic);
                }
            }
        }
    }

    /**
     * Remove the autogenerated subscriptions that are created by findSubscription()
     */
    clearAutoGeneratedSubscriptions = () => {
        const keys = Object.keys(this.subscriptions);

        // add a new direct subscription (is one time slow)
        keys.forEach ((key) => {
            if (this.subscriptions[key].autoGenerated){
                delete this.subscriptions[key];
            }
        });
    }

    /**
     *
     * @param _msg
     */
    subscribe = async (_msg) => {
        this.subscriptions[_msg.topic] = _msg;
        return this.networkBus.subscribe(_msg.QoS, _msg.topic);
    };

    unsubscribeAll = async () => {
        const keys = Object.keys(this.subscriptions);

        // add a new direct subscription (is one time slow)
        for (const key of keys) {
            await this.unsubscribe(key);
        }
    };

    /**
     * unsubscribe from topic
     * @param {*} _topic is a string
     */
    unsubscribe = async (_topic) => {
        await this.unsubscribeAuto(_topic);
        delete this.subscriptions[_topic];
        await this.networkBus.unsubscribe(_topic);
    };

    /**
     * called by unsubscribe(): unsubscribes autogenerated subscriptions that fit to the topic
     * @param _topic
     */
    unsubscribeAuto = async (_topic) =>{
        const topics = Object.keys(this.subscriptions);

        for (const topic of topics){
            if(this.subscriptions[topic].autoGenerated === true){
                if(matchTopic(topic, _topic)){
                    console.log(`removing autogenerated topic: ${topic}`);
                    delete this.subscriptions[topic];
                    await this.networkBus.unsubscribe(topic);
                }
            }
        }
    }

    /**
     * sends a clear retain message to this topic
     * @param {*} _topic 
     */
    clearRetain = async (_topic) => {
        return await this.networkBus.clearRetain(_topic);
    };

    /**
     * 
     * @param {*} _busMsgPub type BusMessage
     */
    publish = async (_busMsgPub) => {
        return await this.networkBus.publish(_busMsgPub.topic, _busMsgPub.payload, _busMsgPub.QoS, _busMsgPub.retain);
    };

    /**
     * messages with empty payload will be ignored.
     * @param {*} _topic 
     * @param {*} _payload 
     * @param {*} _packet //_packet.retain = true only if the messages was sent from the
     * broker as a retained message, and not directly sent.
     */
    networkBusOnMessageReceived = (_topic, _payload, _packet) => {
        if (_payload.length === 0){ //if (_packet.retain && _payload.length == 0){
            //console.log(`only a message to clear retain message (${_topic})`);
            return;
        } 

        //console.log(`whats up (${_topic})?..payload()... packet=(${JSON.stringify(_packet)})`);
        //console.log(`RAW topic (${_topic}) received`);

        // get subscription
        const sub = this.findSubscription(_topic);
        if (sub == null){
            return;
        }

        //console.log(` execute callback (${sub.callback})`);

        sub.callback(_topic, sub.decode(_payload), _packet);
    };

    findSubscription = (_topic) =>{ 
        // check if already subscribed and mapped
        if (this.subscriptions.hasOwnProperty(_topic)){
            return this.subscriptions[_topic];
        }
        
        //console.log(`findSubscription, topic not found (${_topic})`);

        const keys = Object.keys(this.subscriptions);

        let newSub = null;

        // add a new direct subscription (is one time slow)
        keys.forEach ((key) => {
            if (newSub == null && matchTopic(key, _topic)){
                const subscription = this.subscriptions[key];
                newSub = subscription.clone(_topic);
                //console.log(`autgenerate subscribtion(${_topic}), based on (${key})`);
                this.subscriptions[_topic] = newSub;
            }
        });

        return newSub;
    }
}

module.exports = Communicator;